--------------------------------------------------------------------------------
-- Globals
-- Expected transactions per user
N = 2
-- Clone/user IDs
CN = 3
nametype CID = {1..CN} -- Clone ID

-- Operation definition (CRDT-specific)
datatype Operator = add | subtract
nametype Operation = Operator.{1}

-- Vector clock definition
maxTick = CN * N -- A tick for each possible message
nametype Tick = {0..maxTick}
-- To pass over a channel, clock must be a tuple. Vector length = card(CID)
nametype Clock = (Tick, Tick, Tick)

-- Remote channels are from.to.clock.operation
channel send, receive : CID.CID.Clock.Operation
-- A user operates on a clone
channel user : CID.Operation
-- Final state per-clone
channel final : CID.Int

--------------------------------------------------------------------------------
-- Vector clock functions
genesis(v) = (v, v, v)
GENESIS = genesis(0)

peek((t, _, _), 1) = t
peek((_, t, _), 2) = t
peek((_, _, t), 3) = t

put((_, t2, t3), 1, v) = (v, t2, t3)
put((t1, _, t3), 2, v) = (t1, v, t3)
put((t1, t2, _), 3, v) = (t1, t2, v)

tick(time, cid) = put(time, cid, peek(time, cid) + 1)

max(n, nn) = if nn > n then nn else n
min(n, nn) = if nn < n then nn else n

join((t1, t2, t3), (t1n, t2n, t3n)) =
  (max(t1, t1n), max(t2, t2n), max(t3, t3n))

--------------------------------------------------------------------------------
-- Remotes
RemotesEvents = {| send, receive |}

RemoteTransmit(from, to) =
  send.from.to?time?op -> receive.from.to!time!op -> RemoteTransmit(from, to)

Remotes = ||| from : CID, to : CID, to != from @ RemoteTransmit(from, to)

--------------------------------------------------------------------------------
-- CRDT
apply(opr.val, state) = if opr == add then state + val else state - val

--------------------------------------------------------------------------------
-- CRDT domain
Clone(local) = let
  State(
    state, -- CRDT state
    clock, -- Local clock, has internal ticks
    counts,     -- User transaction # per clone
    public -- Latest public times seen
  ) = let
    lastTime(remote) = peek(public, remote)
    -- over the last receipt, we expect to jump one, plus once per incremented cause
    next(remote, nc) = peek(lastTime(remote), remote) + 1 + nc
    -- Seen local tick can be anything up to a current local tick, same as...
    -- Third-party tick can be anything from the last cause that the remote saw
    -- (inclusive) up to what local has seen (causal order)
    causes(remote, other) = (peek(lastTime(remote), other), peek(lastTime(local), other))
    -- (localTime, remoteId) -> acceptable remoteTime
    acceptable(1) = let
      (l2, u2) = causes(1, 2)
      (l3, u3) = causes(1, 3)
    within { (t1, t2, t3) |
      t2 <- {l2..u2}, t3 <- {l3..u3}, t1 <- {next(1, t2-l2 + t3-l3)}, t1 <= maxTick
    }
    acceptable(2) = let
      (l1, u1) = causes(2, 1)
      (l3, u3) = causes(2, 3)
    within { (t1, t2, t3) |
      t1 <- {l1..u1}, t3 <- {l3..u3}, t2 <- {next(2, t1-l1 + t3-l3)}, t2 <= maxTick
    }
    acceptable(3) = let
      (l1, u1) = causes(3, 1)
      (l2, u2) = causes(3, 2)
    within { (t1, t2, t3) |
      t1 <- {l1..u1}, t2 <- {l2..u2}, t3 <- {next(3, t1-l1 + t2-l2)}, t3 <= maxTick
    }
  within
    if counts < (N, N, N) then
      -- Only allow N user txns
      peek(counts, local) < N & user.local?op -> (
        let
          time = tick(clock, local) -- local txn ticks our own clock
          -- Do the sends sequentially in arbitrary order rather than interleave
          -- This makes a massive difference to compilation time (partial order reduction)
          Publish = ; remote : seq(CID), remote != local @ send.local.remote.time.op -> SKIP
        within Publish; State(
          apply(op, state),
          time,
          tick(counts, local),
          put(public, local, time) -- local txn is always public
        )
      )
      []
      -- We can only receive a message for which we have the cause
      [] remote : CID, remote != local, peek(counts, remote) < N, time : acceptable(remote) @ (
        receive.remote.local.time?op -> State(
          apply(op, state),
          tick(join(clock, time), local),
          tick(counts, remote),
          -- Update both remote and local public time
          put(put(public, remote, time), local, join(peek(public, local), time))
        )
      )
    else
      final.local.state -> STOP
within State(0, GENESIS, GENESIS, genesis(GENESIS))

assert Clone(1) :[divergence-free]

Clones = ||| cid : CID @ Clone(cid)
CrdtDomain = (Clones [| RemotesEvents |] Remotes) \ RemotesEvents

--------------------------------------------------------------------------------
-- Domain Specification
--
-- One user per clone does N events, but these all operate sequentially on a
-- single shared state variable.
DomainSpec = let
  Running(state, counts) =
    if counts < (N, N, N) then
      [] cid : CID, peek(counts, cid) < N @
        user.cid?op -> Running(apply(op, state), tick(counts, cid))
    else
      -- Every user reports the same final state value
      ||| cid : CID @ final.cid.state -> SKIP
within
  Running(0, GENESIS)

assert DomainSpec [T= CrdtDomain