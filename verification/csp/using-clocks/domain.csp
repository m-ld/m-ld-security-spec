include "../globals.csp"

--------------------------------------------------------------------------------
-- CRDT
include "../crdt/IntegerSum.module.csp"
include "../crdt/NaiveSet.module.csp"
include "../crdt/OR_Set.module.csp"
-- Selection of CRDT module
instance Crdt = IntegerSum

--------------------------------------------------------------------------------
-- Remotes delivering messages with clocks
include "Clock.module.csp"
-- Remote channels are from.to
channel send, receive : CID.CID.Clock::Clock.Crdt::Operation

RemotesEvents = {| send, receive |}

-- Time increases monotonically
RemoteTransmit(from, to, lastTime) =
  send.from.to?time : Clock::after(lastTime, from)?op ->
    receive.from.to.time.op -> RemoteTransmit(from, to, time)

Remotes = ||| from : CID, to : CID, to != from @ RemoteTransmit(from, to, Clock::GENESIS)

--------------------------------------------------------------------------------
include "../DomainSpec.module.csp"

--------------------------------------------------------------------------------
-- CRDT domain
Clone(local) = let
  State(
    state,  -- CRDT state
    clock,  -- Local clock, has internal ticks
    counts, -- User transaction # per clone
    public  -- Latest public times seen (i.e. excluding internal ticks)
  ) = let
    -- Local user transaction
    Transact = let
      n = peek(counts, local) + 1
      -- Only allow N user txns
    within n <= N & user.local?up ->
      let
        time = Clock::tick(clock, local) -- local txn ticks our own clock
        (newState, op) = Crdt::transact(local.n, state, up)
        -- Do the sends sequentially in arbitrary order rather than interleave
        -- This prevents compilation hang (partial order reduction)
        Publish = ; remote : seq(CID), remote != local @
          send.local.remote.time.op -> SKIP
      within data.local.Crdt::data(newState) -> Publish; State(
        newState,
        time,
        put(counts, local, n),
        put(public, local, time) -- local txn is always public
      )
    -- Remote transaction; we can only receive a message for which we have the cause
    Apply = let
      lastTime(remote) = peek(public, remote)
      -- over the last receipt, we expect to jump one, plus once per incremented cause
      next(remote, nc) = min(peek(lastTime(remote), remote) + 1 + nc, Clock::maxTick)
      -- Seen local tick can be anything up to a current local tick, same as...
      -- Third-party tick can be anything from the last cause that the remote saw
      -- (inclusive) up to what local has seen (causal order)
      causeRange(remote, other) = (peek(lastTime(remote), other), peek(lastTime(local), other))
      -- (remote) -> acceptable remoteTime
      acceptable(1) = let
        (l2, u2) = causeRange(1, 2)
        (l3, u3) = causeRange(1, 3)
      within { (t1, t2, t3) | t2 <- {l2..u2}, t3 <- {l3..u3}, t1 <- {next(1, t2-l2 + t3-l3)} }
      acceptable(2) = let
        (l1, u1) = causeRange(2, 1)
        (l3, u3) = causeRange(2, 3)
      within { (t1, t2, t3) | t1 <- {l1..u1}, t3 <- {l3..u3}, t2 <- {next(2, t1-l1 + t3-l3)} }
      acceptable(3) = let
        (l1, u1) = causeRange(3, 1)
        (l2, u2) = causeRange(3, 2)
      within { (t1, t2, t3) | t1 <- {l1..u1}, t2 <- {l2..u2}, t3 <- {next(3, t1-l1 + t2-l2)} }
    within [] remote : CID, remote != local, peek(counts, remote) < N @
      receive.remote.local?time : acceptable(remote)?op : Crdt::possible(state) -> let
        n = peek(counts, remote) + 1
        newState = Crdt::apply(remote.n, state, op)
      within data.local.Crdt::data(newState) -> State(
        newState,
        Clock::tick(Clock::join(clock, time), local),
        put(counts, remote, n),
        -- Update both remote and local public time
        put(put(public, remote, time), local, Clock::join(peek(public, local), time))
      )
  within counts < (N, N, N) & (Transact [] Apply)
within State(Crdt::initialState, Clock::GENESIS, cidTuple(0), cidTuple(Clock::GENESIS))

assert Clone(1) :[divergence-free]

Users(1) = BlitheUser(1)
Users(2) = ReactiveUser(2)
Users(3) = ReactiveUser(3)

-- 'Node' here is user + clone
Nodes(Users) = ||| cid : CID @ Clone(cid) [| AppEvents(cid) |] Users(cid)
CrdtSystem(Users) = (Nodes(Users) [| RemotesEvents |] Remotes) \ RemotesEvents

-- NaiveSet counterexample
--assert CrdtSystem(Users) [T=
--  user.1.Crdt::Add.1 ->   -- (1,0,0) (0,0,0) (0,0,0)
--  data.1.{1} ->           -- (1,0,0) (0,0,0) (0,0,0)
--  data.3.{1} ->           -- (1,0,0) (0,0,0) (1,0,1)
--  user.3.Crdt::Add.1 ->   -- (1,0,0) (0,0,0) (1,0,2)
--  data.3.{1} ->           -- (1,0,0) (0,0,0) (1,0,2)
--  data.2.{1} ->           -- (1,0,0) (1,1,0) (0,0,0)
--  user.2.Crdt::Remove.1 ->-- (1,0,0) (1,2,0) (0,0,0)
--  data.2.{} ->            -- (1,0,0) (1,2,0) (0,0,0)
--  data.1.{} ->            -- (2,1,0) (1,2,0) (0,0,0)
--  data.2.{1} ->           -- (1,0,0) (1,3,2) (1,0,2)
--  data.3.{} -> STOP

assert ConvergentSystem(Users) [T= CrdtSystem(Users)