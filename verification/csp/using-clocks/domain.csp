include "../globals.csp"

--------------------------------------------------------------------------------
-- CRDT
include "../crdt/IntegerSum.module.csp"
include "../crdt/NaiveSet.module.csp"
include "../crdt/OR_Set.module.csp"
-- Selection of CRDT module and value set
--instance Crdt = IntegerSum
instance Crdt = NaiveSet({1})
--instance Crdt = OR_Set({1})

--------------------------------------------------------------------------------
-- Remotes delivering messages with clocks
include "Clock.module.csp"
-- Remote channels are from.to
channel send, receive : CID.CID.Clock::Clock.Crdt::Operation

RemotesEvents = {| send, receive |}

RemoteTransmit(from, to) =
  send.from.to?time?op ->
    receive.from.to.time.op ->
      RemoteTransmit(from, to)

Remotes = ||| from : CID, to : CID, to != from @ RemoteTransmit(from, to)

--------------------------------------------------------------------------------
include "../DomainSpec.module.csp"

--------------------------------------------------------------------------------
-- CRDT domain
Clone(local) = let
  State(
    state,  -- CRDT state
    clock,  -- Local clock, has internal ticks
    gwc     -- Latest public times seen
  ) = let
    counts = Gwc::counts(gwc)
    -- Local user transaction
    Transact = let
      n = peek(counts, local) + 1
      -- Only allow N user txns
    within n <= N & user.local?up -> let
      time = Clock::tick(clock, local) -- local txn ticks our own clock
      (newState, op) = Crdt::transact(local.n, state, up)
      -- Do the sends sequentially in arbitrary order rather than interleave
      -- This prevents compilation hang (partial order reduction)
      Publish = ; remote : seq(CID), remote != local @
        send.local.remote.time.op -> SKIP
    within data.local.Crdt::data(newState) -> Publish; State(
      newState,
      time,
      Gwc::update(gwc, local, time)
    )
    -- Remote transaction; we can only receive a message for which we have the cause
    Apply = [] remote : CID, remote != local, peek(counts, remote) < N @
      receive.remote.local
        ?time : Gwc::acceptable(gwc, local, remote)
        ?op : Crdt::possible(state) -> let
        n = peek(counts, remote) + 1
        newState = Crdt::apply(remote.n, state, op)
      within data.local.Crdt::data(newState) -> State(
        newState,
        Clock::tick(Clock::join(clock, time), local),
        Gwc::updateRemote(gwc, local, remote, time)
      )
  within counts < (N, N, N) & (Transact [] Apply)
within State(Crdt::initialState, Clock::GENESIS, Gwc::GENESIS)

assert Clone(1) :[divergence-free]

Users(1) = BlitheUser(1)
Users(2) = ReactiveUser(2)
Users(3) = ReactiveUser(3)

-- 'Node' here is user + clone
Nodes(Users) = ||| cid : CID @ Clone(cid) [| AppEvents(cid) |] Users(cid)
CrdtSystem(Users) = (Nodes(Users) [| RemotesEvents |] Remotes) \ RemotesEvents

-- NaiveSet counterexample
--assert CrdtSystem(Users) [T=
--  user.1.Crdt::Add.1 ->   -- (1,0,0) (0,0,0) (0,0,0)
--  data.1.{1} ->           -- (1,0,0) (0,0,0) (0,0,0)
--  data.3.{1} ->           -- (1,0,0) (0,0,0) (1,0,1)
--  user.3.Crdt::Add.1 ->   -- (1,0,0) (0,0,0) (1,0,2)
--  data.3.{1} ->           -- (1,0,0) (0,0,0) (1,0,2)
--  data.2.{1} ->           -- (1,0,0) (1,1,0) (0,0,0)
--  user.2.Crdt::Remove.1 ->-- (1,0,0) (1,2,0) (0,0,0)
--  data.2.{} ->            -- (1,0,0) (1,2,0) (0,0,0)
--  data.1.{} ->            -- (2,1,0) (1,2,0) (0,0,0)
--  data.2.{1} ->           -- (1,0,0) (1,3,2) (1,0,2)
--  data.3.{} -> STOP

assert ConvergentSystem(Users) [T= CrdtSystem(Users)